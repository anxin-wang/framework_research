# [Mozilla JavaScript Reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference)

#语句

##var

var定义的变量有其上下文语境，在函数内定义的变量作用域在函数内，在函数外定义的变量为全局变量。</br>
不用var定义的变量在strict mode中会报错，在non-strict mode中相当于全局变量。请看下例：

<pre><code>
var x = 0;  // x is declared global, then assigned a value of 0

console.log(typeof z); // undefined, since z doesn't exist yet

function a() { // when a is called,
  var y = 2;   // y is declared local to function a, then assigned a value of 2

  console.log(x, y);   // 0 2 

  function b() {       // when b is called
    x = 3;  // assigns 3 to existing global x, doesn't create a new global var
    y = 4;  // assigns 4 to existing outer y, doesn't create a new global var
    z = 5;  // creates a new global variable z and assigns a value of 5. 
  }         // (Throws a ReferenceError in strict mode.)

  b();     // calling b creates z as a global variable
  console.log(x, y, z);  // 3 4 5
}

a();                   // calling a also calls b
console.log(x, z);     // 3 5
console.log(typeof y); // undefined as y is local to function a
</code></pre>

另外，还要知道一个变量提升（var hoisting）的概念，虽然正常使用中都是定义在前，使用在后。但是要清楚使用在前，定义在后的情况是怎么样的。（也就面试会考到）

##let
定义了一个块级作用域的变量，这个变量在哪个block中（即大括号括起来的区域）就只能在该block中使用</br>
let var1 [= value1] [, var2 [= value2]] [, ..., varN [= valueN]];

Example:
<pre><code>
function varTest() {
  var x = 1;
  if (true) {
    var x = 2;  // same variable!
    console.log(x);  // 2
  }
  console.log(x);  // 2
}

function letTest() {
  let x = 1;
  if (true) {
    let x = 2;  // different variable
    console.log(x);  // 2
  }
  console.log(x);  // 1
}
</code></pre>

创建私有变量

<pre><code>
var SomeConstructor;

{
    let privateScope = {};

    SomeConstructor = function SomeConstructor () {
        this.someProperty = "foo";
        privateScope.hiddenProperty = "bar";
    }

    SomeConstructor.prototype.showPublic = function () {
        console.log(this.someProperty); // foo
    }

    SomeConstructor.prototype.showPrivate = function () {
        console.log(privateScope.hiddenProperty); // bar
    }

}

var myInstance = new SomeConstructor();

myInstance.showPublic();
myInstance.showPrivate();

console.log(privateScope.hiddenProperty); // error
</code></pre>


不可在同一个区域中重复定义

<pre><code>
if (x) {
  let foo;
  let foo; // SyntaxError thrown.
}

</code></pre>

不能使用函数参数中的变量名
<pre><code>
function go(n){
  for (let n of n.a) { // TypeError: n is undefined
    console.log(n);
  }
}

go({a:[1,2,3]});
</code></pre>


##const

定义静态变量:必须在定义的时候初始化</br>
const name1 = value1 [, name2 = value2 [, ... [, nameN = valueN]]];

例子

<pre><code>
// NOTE: Constants can be declared with uppercase or lowercase, but a common
// convention is to use all-uppercase letters.

// define MY_FAV as a constant and give it the value 7
const MY_FAV = 7;

// this will throw an error
MY_FAV = 20;

// will print 7
console.log("my favorite number is: " + MY_FAV);

// trying to redeclare a constant throws an error
const MY_FAV = 20;

// the name MY_FAV is reserved for constant above, so this will also fail
var MY_FAV = 20;

// this throws an error also
let MY_FAV = 20;

// it's important to note the nature of block scoping
if (MY_FAV === 7) { 
    // this is fine and creates a block scoped MY_FAV variable 
    // (works equally well with let to declare a block scoped non const variable)
    const MY_FAV = 20;

    // MY_FAV is now 20
    console.log("my favorite number is " + MY_FAV);

    // this gets hoisted into the global context and throws an error
    var MY_FAV = 20;
}

// MY_FAV is still 7
console.log("my favorite number is " + MY_FAV);

// Assigning to A const variable is a syntax error
const A = 1; A = 2;

// throws an error, missing initializer in const declaration
const FOO; 

// const also works on objects
const MY_OBJECT = {"key": "value"};

// Attempting to overwrie the object throws an error
MY_OBJECT = {"OTHER_KEY": "value"};

// However, object keys are not protected,
// so the following statement is executed without problem
MY_OBJECT.key = "otherValue"; // Use Object.freeze() to make object immutable

// The same applies to arrays
const MY_ARRAY = [];
// It's possible to push items into the array
MY_ARRAY.push("A"); // ["A"]
// However, assigning a new array to the variable throws an error
MY_ARRAY = ["B"]
</code></pre>

##function

function定义分为表达式和语句。函数默认返回undefined,除非使用return语句。表达式和语句的区别是表达式中函数名可以省略，从而创造出匿名函数，语法如下：</br>

<pre><code>
//表达式
function [name]([param1[, param2[, ..., paramN]]]) {
   statements
}
//语句
function name([param,[, param,[..., param]]]) {
   [statements]
}
</code></pre>

**函数提升**
<pre><code>
hoisted(); // logs "foo"

function hoisted() {
  console.log("foo");
}

//这样不会提升
notHoisted(); // TypeError: notHoisted is not a function

var notHoisted = function() {
   console.log("bar");
};
</code></pre>
**函数表达式可以用来创建IIFE (Immediately Invoked Function Expression) ，定义完就运行。
**

Example：
<pre><code>
//匿名的函数表达式
var x = function(y) {
   return y * y;
};

//命名的函数表达式
var math = {
  'factorial': function factorial(n) {
    if (n <= 1)
      return 1;
    return n * factorial(n - 1);
  }
};
</code></pre>

##function*

##yield

##yield*


##for…of
创建了一个可迭代对象，包括Array, Map, Set, String, TypedArray, arguments对象等的迭代。

语法
<pre><code>
for (variable of iterable) {
  statement
}
</code></pre>

Array
<pre><code>
let iterable = [10, 20, 30];

for (let value of iterable) {
  console.log(value);
}
// 10
// 20
// 30
</code></pre>

<pre><code>
let iterable = [10, 20, 30];

for (const value of iterable) {
  console.log(value);
}
// 10
// 20
// 30
</code></pre>

String
<pre><code>
let iterable = "boo";

for (let value of iterable) {
  console.log(value);
}
// "b"
// "o"
// "o"
</code></pre>

 Map
<pre><code>
let iterable = new Map([["a", 1], ["b", 2], ["c", 3]]);

for (let entry of iterable) {
  console.log(entry);
}
// [a, 1]
// [b, 2]
// [c, 3]

for (let [key, value] of iterable) {
  console.log(value);
}
// 1
// 2
// 3
</code></pre>


Set
<pre><code>
let iterable = new Set([1, 1, 2, 2, 3, 3]);

for (let value of iterable) {
  console.log(value);
}
// 1
// 2
// 3
</code></pre>



DOM collection
<pre><code>
// Note: This will only work in platforms that have
// implemented NodeList.prototype[Symbol.iterator]
let articleParagraphs = document.querySelectorAll("article > p");

for (let paragraph of articleParagraphs) {
  paragraph.classList.add("read");
}
</code></pre>

generators
<pre><code>
function* fibonacci() { // a generator function
  let [prev, curr] = [1, 1];
  while (true) {
    [prev, curr] = [curr, prev + curr];
    yield curr;
  }
}

for (let n of fibonacci()) {
  console.log(n);
  // truncate the sequence at 1000
  if (n >= 1000) {
    break;
  }
}
</code></pre>


iterable objects
<pre><code>
var iterable = {
  [Symbol.iterator]() {
    return {
      i: 0,
      next() {
        if (this.i < 3) {
          return { value: this.i++, done: false };
        }
        return { value: undefined, done: true };
      }
    };
  }
};

for (var value of iterable) {
  console.log(value);
}
// 0
// 1
// 2
</code></pre>

for…in与for…of的区别

for…in会迭代所有object属性，而for…of则用于集合，或object中含有[Symbol.iterator]的元素
<pre><code>
Object.prototype.objCustom = function () {}; 
Array.prototype.arrCustom = function () {};

let iterable = [3, 5, 7];
iterable.foo = "hello";

for (let i in iterable) {
  console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom"
}

for (let i of iterable) {
  console.log(i); // logs 3, 5, 7
}
</code></pre>


##class

class分为语句和表达式。区别是是否可以重复定义，语句不可以重复定义，而表达式可以。另外表达式可以省略类名，而语句不可以。相同点是constructor都是可选项。

1.语句

class name [extends] {
  // class body
}

<pre><code>
class Polygon {
  constructor(height, width) {
    this.name = 'Polygon';
    this.height = height;
    this.width = width;
  }
}

class Square extends Polygon {
  constructor(length) {
    super(length, length);
    this.name = 'Square';
  }
}
</code></pre>

2.表达式

var MyClass = class [className] [extends] {
  // class body
};

<pre><code>
'use strict';
var Foo = class {}; // constructor property is optional
var Foo = class {}; // Re-declaration is allowed

typeof Foo; //returns "function"
typeof class {}; //returns "function"

Foo instanceof Object; // true
Foo instanceof Function; // true
class Foo {}; // Throws TypeError, doesn't allow re-declaration
</code></pre>

未命名的class

<pre><code>
var Foo = class {
  constructor() {}
  bar() {
    return "Hello World!";
  }
};

var instance = new Foo();
instance.bar(); // "Hello World!"
Foo.name; // "Foo"
</code></pre>



命名的class
<pre><code>
var Foo = class NamedFoo {
  constructor() {}
  whoIsThere() {
    return NamedFoo.name;
  }
}
var bar = new Foo();
bar.whoIsThere(); // "NamedFoo"
NamedFoo.name; // ReferenceError: NamedFoo is not defined
Foo.name; // "NamedFoo"
</code></pre>


##export
语法：
<pre><code>
export { name1, name2, …, nameN };
export { variable1 as name1, variable2 as name2, …, nameN };
export let name1, name2, …, nameN; // also var
export let name1 = …, name2 = …, …, nameN; // also var, const

export default expression;
export default function (…) { … } // also class, function*
export default function name1(…) { … } // also class, function*
export { name1 as default, … };

export * from …;
export { name1, name2, …, nameN } from …;
export { import1 as name1, import2 as name2, …, nameN } from …;
</code></pre>

<pre><code>
//命名export
export { myFunction }; // exports a function declared earlier
export const foo = Math.sqrt(2); // exports a constant

//默认exports,每个script只有一个
export default function() {} // or 'export default class {}'
// there is no semi-colon here
</code></pre>

例子：
命名export
<pre><code>
// module "my-module.js"
function cube(x) {
  return x * x * x;
}
const foo = Math.PI + Math.SQRT2;
export { cube, foo };

//main.js
import { cube, foo } from 'my-module';
console.log(cube(3)); // 27
console.log(foo);    // 4.555806215962888

</code></pre>

默认export
<pre><code>
// module "my-module.js"
export default function cube(x) {
  return x * x * x;
}

main.js
import cube from 'my-module';
console.log(cube(3)); // 27
</code></pre>

##import

语法：

<pre><code>
import defaultMember from "module-name";
import * as name from "module-name";
import { member } from "module-name";
import { member as alias } from "module-name";
import { member1 , member2 } from "module-name";
import { member1 , member2 as alias2 , [...] } from "module-name";
import defaultMember, { member [ , [...] ] } from "module-name";
import defaultMember, * as name from "module-name";
import "module-name";
</code></pre>


<pre><code>
// --file.js--
function getJSON(url, callback) {
  let xhr = new XMLHttpRequest();
  xhr.onload = function () { 
    callback(this.responseText) 
  };
  xhr.open("GET", url, true);
  xhr.send();
}

export function getUsefulContents(url, callback) {
  getJSON(url, data => callback(JSON.parse(data)));
}

// --main.js--
import { getUsefulContents } from "file";
getUsefulContents("http://www.example.com", data => {
  doSomethingUseful(data);
});
</code></pre>